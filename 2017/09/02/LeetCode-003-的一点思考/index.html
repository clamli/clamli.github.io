<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>LeetCode 003 的一点思考 | Clamli</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Qustion:  Given a string, find the length of the longest substring without repeating characters.  Examples:  Given &amp;quot;abcabcbb&amp;quot;, the answer is &amp;quot;abc&amp;quot;, which the length is 3. Given &amp;qu">
<meta name="keywords" content="leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 003 的一点思考">
<meta property="og:url" content="http://clamli.github.io/2017/09/02/LeetCode-003-的一点思考/index.html">
<meta property="og:site_name" content="Clamli">
<meta property="og:description" content="Qustion:  Given a string, find the length of the longest substring without repeating characters.  Examples:  Given &amp;quot;abcabcbb&amp;quot;, the answer is &amp;quot;abc&amp;quot;, which the length is 3. Given &amp;qu">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://clamli.github.io/images/LeetCode-003/test%20error.bmp">
<meta property="og:image" content="http://clamli.github.io/images/LeetCode-003/problem.bmp">
<meta property="og:updated_time" content="2018-04-26T16:43:20.818Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode 003 的一点思考">
<meta name="twitter:description" content="Qustion:  Given a string, find the length of the longest substring without repeating characters.  Examples:  Given &amp;quot;abcabcbb&amp;quot;, the answer is &amp;quot;abc&amp;quot;, which the length is 3. Given &amp;qu">
<meta name="twitter:image" content="http://clamli.github.io/images/LeetCode-003/test%20error.bmp">
  
  
    <link rel="icon" href="/images/favicon.jpg">
  
  <link rel="stylesheet" href="/css/typing.css">
  <link rel="stylesheet" href="/css/donate.css">
  
</head>
</html>
  
    
      <body>
    
  
      <div id="container" class="container">
        <article id="post-LeetCode-003-的一点思考" class="article article-type-post" itemscope="" itemprop="blogPost">
  <header id="header" class="header">
    <div class="mobile-nav">
      <h1 class="nickname">Boyi Li</h1>
      <a id="menu">
        &#9776; Menu
      </a>
    </div>
    
        <nav id="main-nav" class="main-nav nav-left">
    
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/notes">Notes</a>
    
      <a class="main-nav-link" href="/projects">Projects</a>
    
      <a class="main-nav-link" href="/resume">Resume</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
      <a class="main-nav-link" href="/to-do-list">To-do List</a>
    
  </nav>
</header>

  <hr>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LeetCode 003 的一点思考
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <h3><span id="qustion">Qustion:</span></h3><p>  Given a string, find the length of the longest substring without repeating characters.<br>  Examples:</p>
<ul>
<li>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</li>
<li>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</li>
<li>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3.</li>
</ul>
<hr>
<h3><span id="coding">Coding:</span></h3><p>拿到题目我的第一个思路是这是一个可以通过遍历完成的题，因为所有的情况之和明显是O(N^2)的时间复杂度。因此我的第一个方法如下：<a id="more"></a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">-1</span>, <span class="number">256</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">	 <span class="keyword">for</span>(j=i; j&lt;len; j++) &#123;</span><br><span class="line">	 	<span class="keyword">if</span> (arr[s[j]-<span class="string">'\0'</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">	 		i = arr[s[j]-<span class="string">'\0'</span>];</span><br><span class="line">	 		<span class="keyword">if</span>(llen &gt; maxllen)</span><br><span class="line">	 			maxllen = llen;</span><br><span class="line">	 		llen = <span class="number">0</span>;</span><br><span class="line">	 		<span class="built_in">memset</span>(arr, <span class="number">-1</span>, <span class="number">256</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	 		<span class="keyword">break</span>;         <span class="comment">//1</span></span><br><span class="line">	 	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 		llen++;</span><br><span class="line">	 		arr[s[j]-<span class="string">'\0'</span>] = j;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 &#125;		</span><br><span class="line">	 <span class="keyword">if</span>(j == len) &#123;</span><br><span class="line">	 	<span class="keyword">if</span>(llen &gt; maxllen)</span><br><span class="line">	 		maxllen = llen;</span><br><span class="line">	 	<span class="keyword">break</span>;            <span class="comment">//2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中为了略微提高一下效率，使用了两个<code>break</code>。第一个是当在以<code>i</code>起始，<code>j</code>结尾的字符串中找到相同的两个字符时，另i直接定位到两个相同字符的前一个字符的后一位上，然后<code>break</code>。这是因为一定不会再出现包含这两个相同字符的子串满足要求，所以可以直接将<code>i</code>的位置后移。第二个是在一轮<code>j</code>的循环结束时，这时如果一直没有碰到过重复出现的字符，则表示从当前的<code>i</code>到结尾的整个子串上都没有重复的字符，所以当前的<code>maxllen</code>已经是全局最优的，这时也可以直接<code>break</code>结束。</p>
<p>结果在我提交上去这个版本的代码之后，卡在了这题的最后一个测试点上，显示的原因是运行超时。很显然，这样的遍历方法不是题目所期望的。所以就有了下面的一种方法，用动态规划来解决。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!len)</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">	<span class="keyword">for</span> (j=i<span class="number">-1</span>; j&gt;=last_start; j--) &#123;</span><br><span class="line">	 	<span class="keyword">if</span>(s[j] == s[i]) &#123;  <span class="comment">//1</span></span><br><span class="line">	 		dp[i] = i - j;</span><br><span class="line">	 		last_start = j + <span class="number">1</span>;</span><br><span class="line">	 		<span class="keyword">break</span>;</span><br><span class="line">	 	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(j == last_start) &#123;  <span class="comment">//2</span></span><br><span class="line">	 		dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">	 	&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span>(dp[i] &gt; maxllen) &#123;</span><br><span class="line">	 	maxllen = dp[i];</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的思路其实和我上面的解法思路有一点类似：对于任意一个位置点i，我们将它能与之前的点构成的最大子串的长度记作dp[i]（其中dp[0]=1）。对于每个位置来说，我们往前遍历，如果和该位置字符相同的字符的位置在上一轮相同位置字符的后面，则更新当前位置的 dp[i] = i-j ，并更新上一轮相同位置字符的位置到当前相同字符中前一个字符的位置后面；否则，说明当前位置的字符到上一轮相同位置字符之间没有相同的字符，则 dp[i] = dp[i-1] + 1 。由于这种方法在每次循环中均不需要完全遍历，所以效率相对较高。</p>
<p>但是上一个算法的时间复杂度仍然是O(N^2)数量级的，其实还可以存在一种时间复杂度只有O(N)的算法，就是用hash表来记录每个位置之前是否出现过某个字符，并且记录该字符坐标。这样可以不需要在for循环中进行遍历，可以直接从hash表中取得结果，速度快了不少。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!len)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(hash, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">256</span>);</span><br><span class="line">hash[s[<span class="number">0</span>]-<span class="string">'\0'</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">	ind = s[i]-<span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">if</span>(hash[ind] != <span class="number">-1</span> &amp;&amp; hash[ind] &gt;= last_same) &#123;</span><br><span class="line">		dp[i] = i - hash[ind];</span><br><span class="line">		last_same = hash[ind] + <span class="number">1</span>;</span><br><span class="line">		hash[ind] = i;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">		hash[ind] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dp[i] &gt; maxllen) &#123;</span><br><span class="line">		maxllen = dp[i];</span><br><span class="line">		<span class="keyword">if</span>(maxllen == <span class="number">127</span>)</span><br><span class="line">			k = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中hash表中存每一个字符是否在之前出现过，如果出现过，记录它的位置坐标，如果没有，则为-1。因此每次可以很快地判断出当前字符在之前是否曾出现。</p>
<p>但当时把这个版本提交上去的时候发现所有测试点都顺利通过，除了最后一个：<br><img src="/images/LeetCode-003/test error.bmp" alt="">如图所示，输出结果应该是95的可是变成了127。调试了半天以后发现原来是错把<code>hash</code>定义为char类型了。<br><img src="/images/LeetCode-003/problem.bmp" alt="">如上图所示，这个时候如果在里面存储如128之类的数字，机器会自动理解成-128(因为是1字节，10000000)，所以导致了错误。因此这个hash的类型必须是int类型。</p>
<p>完整代码可参见我的Github: <a href="https://github.com/clamli/leetcode/blob/master/l_substring_without_rep.c" target="_blank" rel="noopener">l_substring_without_rep.c</a></p>
<hr>
<h1><span id="reference">Reference:</span></h1><ul>
<li><a href="http://www.ahathinking.com/archives/123.html" target="_blank" rel="noopener">最长不重复子串</a></li>
</ul>

      
      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2017/09/02/LeetCode-003-的一点思考/" class="article-date">
  <time datetime="2017-09-02T15:47:07.000Z" itemprop="datePublished">2017-09-02</time>
</a>

        </li>
        
        
          <li>
            <span class="label">Tag:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li></ul>


          </li>
        
        <hr>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2017/09/13/LeetCode-004-Regular-Expression-Matching/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          LeetCode 004 简单的正则语言匹配器
        
      </div>
    </a>
  
  
    <span id="article-nav-older" class="article-nav-link-wrap older"></span>
  
</nav>


  
</article>










      </div>
      
    <footer id="footer" class="post-footer footer">
      
      <hr>
      <div id="footerContent" class="footer-content">
        <p>Fill what’s empty. Empty what’s full. Scratch where it itches.</p>


      </div>
    </footer>

      







<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.5.10/clipboard.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->







    </div>
  </body>
</html>
